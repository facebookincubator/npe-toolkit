/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import * as React from 'react';
import {useLogEvent} from '@toolkit/core/api/Log';
import {
  StatusApiType,
  useBackgroundStatus,
  useStatus,
} from '@toolkit/core/client/UserMessaging';
import {Opt} from '@toolkit/core/util/Types';
import {withTimeout} from '../util/DevUtil';

type ARGS = any[];

/**
 * Convenience type for (potentially) async operations.
 *
 * Actions all have a `Handler` that is used to execute the core
 * operation of the action.
 */
export type Handler<I extends ARGS = [void], O = void> =
  | ((...args: I) => O)
  | ((...args: I) => Promise<O>);

/**
 * A type for Actions that need to call hooks.
 *
 * When actions are defined inline in a React component, they
 * can reference results of hooks called outside of the function scope.
 *
 * However for an `Action` defined outside a React component, you often
 * need a way call hooks (e.g. `useLogggedInUser()` or `useNav()`)
 *
 * `UseAction` is a function that is executed at the render phase, and then
 * returns the underlying `Handler` that can be called at any time within
 * the component.
 *
 * The `use` param is a marker so that code can distiguish between this and a
 * raw `Handler`. Use `actionHook()` utility to create.
 */
export type UseAction<I extends ARGS, O> = () => Handler<I, O> & {use: true};

/**
 * Utility to create a `UseAction`.
 */
export function actionHook<I extends ARGS, O>(
  hook: () => Handler<I, O>,
): UseAction<I, O> {
  const result = hook as UseAction<I, O>;
  /** @ts-ignore */
  result.use = true;
  return result;
}

/**
 * Actions are system or user operations that need to share common cross-cutting functionality.
 * Examples of cross-cutting functionality include:
 * - Logging and analytics
 * - Pending handling - showing user interface to indicate that an action is in progress
 * - Error handling - letting the user know that the operation succeeded or failed
 * - Ensuring that async operations have a maximum timeout so the app doesn't hang
 *
 * Actions are recommended whenever an async operation is started as a result of user action,
 * e.g. pressing on a button, and also for background tasks initiated by the system.
 *
 * Although these cross-cutting concerns aren't always handled uniformly, even within one app,
 * providing a common API and set of utilities on top of this API makes it easier to correctly
 * support shared behavior,
 *
 * Actions have a `Handler` which is the function that executes the use-case specific business logic.
 * This function should throw an exception if the request is not successful from the user or system
 * perspective.
 *
 * Actions can also execute hooks by using the `UseAction` variant, which allows you to have a function called
 * during component rendering that can call hooks and return the `Handler`.
 *
 * Actions need to have an ID assigned to them for logging purposes. This is not part of the core action object
 * as the system can assign IDs to actions which are good enough for initial development. When calling
 * `useAction` you can use an autogenerated ID based on the function name, or pass in an ID.
 */
export type Action<I extends ARGS = [void], O = void> =
  | Handler<I, O>
  | UseAction<I, O>;

/**
 * ActionItem are a common structure that includes both the action as well as metadata to generate
 * UI that triggers the action.
 *
 * For example, `Screen`s have a `mainAction` field which allows defining a UI element that is visible
 * in the chrome of the screen.
 *
 * `id` is required for UIActions as they frequently use anonymous functions which make it difficult to
 * infer a name for logging purposes.
 */
export type ActionItem = {
  id: string;
  action: Action;
  label?: string;
  icon?: string;
};

// Internal function to resolve `UseAction` to a `Handler` if needed and execute hooks
function executeHooks<I extends ARGS, O>(action: Action<I, O>): Handler<I, O> {
  if ('use' in action && action['use']) {
    return action() as Handler<I, O>;
  } else {
    return action as Handler<I, O>;
  }
}

type ActionStatus<I extends ARGS, O> = [
  handler: Handler<I, O>,
  pending: boolean,
  error: Opt<Error>,
];

type ActionOpts = {
  /** Timeout in milliseconds */
  timeout?: number;
  /** Whether to show status in the `screen` (default) or the `app`-wide Status handler */
  type?: StatusApiType;
};

export function useAction<I extends ARGS, O>(
  action: Action<I, O>,
  opts?: ActionOpts,
): ActionStatus<I, O>;
export function useAction<I extends ARGS, O>(
  id: string,
  action: Action<I, O>,
  opts?: ActionOpts,
): ActionStatus<I, O>;

/**
 * Components executing actions call useAction() hook during component rendering
 * to get an `Handler` that can be executed and will handle all cross-cutting concerns
 *
 * `useAction` does two things:
 * 1. Executes hooks correctly, so that Actions can use context
 * 2. Provides support for cross-cutting concerns such as logging
 *
 * Example:
 * ```
 * function ActionButton(props: {action: Action}) {
 *   const {id, icon, label, act} = useAction(action);
 *   return <Button icon={icon} onPress={() => act()}>{label}</Button>;
 * }
 * ```
 */
export function useAction<I extends ARGS, O>(
  arg0: string | Action<I, O>,
  arg1?: Action<I, O> | ActionOpts,
  arg2?: ActionOpts,
): ActionStatus<I, O> {
  // See overloads above
  const action = typeof arg1 === 'function' ? arg1 : (arg0 as Action<I, O>);

  // TODO: Warn if name is anonymous and no ID provided
  // TODO: Add screen info to ID
  const id = typeof arg1 === 'string' ? arg1 : action.name;
  const opts = arg2 ?? (arg1 as ActionOpts) ?? {};

  return useActionImpl(id, action, {...opts});
}

const DEFAULT_TIMEOUT = 60000;

export function useActionImpl<I extends ARGS, O>(
  id: Opt<string>,
  action: Action<I, O>,
  opts: ActionOpts,
): ActionStatus<I, O> {
  const {timeout = DEFAULT_TIMEOUT, type = 'screen'} = opts;
  const {error, setError} = type == 'app' ? useBackgroundStatus() : useStatus();
  const logEvent = useLogEvent();
  const [pending, setPending] = React.useState(false);
  const handler = executeHooks(action);

  async function wrappedHandler(...args: I) {
    try {
      setPending(true);
      setError(undefined);
      return await withTimeout(() => handler(...args), timeout);
    } catch (e: any) {
      console.log('WRAPPED HANDLER ERRORINO', e);
      setError(e as Error);
      throw e;
    } finally {
      setPending(false);
      // TODO: Log errors
      // TODO: Get app ID, user from context
      logEvent('ACTION_' + id);
    }
  }

  return [wrappedHandler, pending, error];
}
